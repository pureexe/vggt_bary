<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js GLB Interpolation</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="loading-overlay">Loading models...</div>
    <canvas id="threejs-canvas"></canvas>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        let scene, camera, renderer, controls;
        let jsonData = []; // This will hold your input JSON data, loaded from file
        const loadedModels = []; // To store references to loaded GLB objects and their original positions
        let needsGLBUpdate = false; // Flag to control when GLB visibility/opacity needs update

        // --- JSON File Path ---
        // IMPORTANT: Ensure this 'data.json' file exists in the same directory as your HTML file
        // or provide the correct path.
        const JSON_FILE_PATH = 'data.json';

        // --- Helper function to make materials self-illuminating ---
        // This ensures the material's color/texture is rendered directly without strong light influence.
        function makeMaterialSelfIlluminating(material) {
            if (material) {
                // Ensure material supports emissive property (e.g., MeshStandardMaterial, MeshPhysicalMaterial)
                if (material.isMeshStandardMaterial || material.isMeshPhysicalMaterial) {
                    material.emissive.copy(material.color); // Make emissive color the same as base color
                    material.emissiveIntensity = 1; // Full emissive intensity
                    if (material.map) {
                        material.emissiveMap = material.map; // Use the texture as emissive map too
                    }
                }
                // Also ensure transparency for opacity effects
                material.transparent = true;
                // For transparent materials, alphaTest can help with rendering artifacts
                material.alphaTest = 0.001;
                material.needsUpdate = true; // Mark material for update
            }
        }

        // Ensure all materials on a mesh are transparent and self-illuminating
        function prepareModelMaterials(object) {
            object.traverse((child) => {
                if (child.isMesh) {
                    makeMaterialSelfIlluminating(child.material);
                    // Handle multi-materials if they exist
                    if (Array.isArray(child.material)) {
                        child.material.forEach(makeMaterialSelfIlluminating);
                    }
                }
            });
        }

        // Function to convert intrinsic and extrinsic matrices to Three.js camera setup
        function setupCameraFromMatrices(cameraInstance, intrinsic, extrinsic, canvasWidth, canvasHeight) {
            const fx = intrinsic[0][0];
            const fy = intrinsic[1][1];
            const cx = intrinsic[0][2];
            const cy = intrinsic[1][2];

            const near = 0.1;
            const far = 1000;

            const P = new THREE.Matrix4();
            P.set(
                2 * fx / canvasWidth,   0,                          (1 - 2 * cx / canvasWidth),   0,
                0,                     -(2 * fy / canvasHeight),   (2 * cy / canvasHeight - 1),  0,
                0,                     0,                          -(far + near) / (far - near), -2 * far * near / (far - near),
                0,                     0,                          -1,                           0
            );
            cameraInstance.projectionMatrix.copy(P);
            cameraInstance.projectionMatrixInverse.copy(P).invert();

            const R_extrinsic = new THREE.Matrix3();
            R_extrinsic.set(
                extrinsic[0][0], extrinsic[0][1], extrinsic[0][2],
                extrinsic[1][0], extrinsic[1][1], extrinsic[1][2],
                extrinsic[2][0], extrinsic[2][1], extrinsic[2][2]
            );

            const t_extrinsic = new THREE.Vector3(extrinsic[0][3], extrinsic[1][3], extrinsic[2][3]);

            const viewMatrix = new THREE.Matrix4();
            viewMatrix.set(
                R_extrinsic.elements[0], R_extrinsic.elements[3], R_extrinsic.elements[6], t_extrinsic.x,
                R_extrinsic.elements[1], R_extrinsic.elements[4], R_extrinsic.elements[7], t_extrinsic.y,
                R_extrinsic.elements[2], R_extrinsic.elements[5], R_extrinsic.elements[8], t_extrinsic.z,
                0, 0, 0, 1
            );

            cameraInstance.matrixWorld.copy(viewMatrix).invert();
            cameraInstance.matrixWorld.decompose(cameraInstance.position, cameraInstance.quaternion, cameraInstance.scale);
            cameraInstance.updateMatrixWorld();
        }

        // Function to extract position from extrinsic matrix (for GLB placement)
        function getPositionFromExtrinsic(extrinsic) {
            const R_extrinsic = new THREE.Matrix3();
            R_extrinsic.set(
                extrinsic[0][0], extrinsic[0][1], extrinsic[0][2],
                extrinsic[1][0], extrinsic[1][1], extrinsic[1][2],
                extrinsic[2][0], extrinsic[2][1], extrinsic[2][2]
            );

            const t_extrinsic = new THREE.Vector3(extrinsic[0][3], extrinsic[1][3], extrinsic[2][3]);

            const R_transpose = new THREE.Matrix3().copy(R_extrinsic).transpose();
            const worldPosition = t_extrinsic.clone().applyMatrix3(R_transpose).negate();
            return worldPosition;
        }

        // Function to update the visibility and opacity of GLB models
        function updateGLBVisibility() {
            if (!needsGLBUpdate) return;
            needsGLBUpdate = false;

            const cameraPosition = camera.position;

            const modelsWithDistances = loadedModels.map(item => {
                const distance = cameraPosition.distanceTo(item.worldPosition);
                return { model: item.model, distance: distance };
            });

            modelsWithDistances.sort((a, b) => a.distance - b.distance);
            const closestThree = modelsWithDistances.slice(0, 3);

            let totalInverseDistance = 0;
            closestThree.forEach(item => {
                totalInverseDistance += 1 / (item.distance + 0.001);
            });

            loadedModels.forEach(item => {
                item.model.traverse((child) => {
                    if (child.isMesh) {
                        child.material.opacity = 0;
                        child.material.visible = false;
                        child.material.needsUpdate = true;
                    }
                });
            });

            closestThree.forEach(item => {
                const weight = (1 / (item.distance + 0.001)) / totalInverseDistance;
                item.model.traverse((child) => {
                    if (child.isMesh) {
                        child.material.opacity = weight;
                        child.material.visible = true;
                        child.material.needsUpdate = true;
                    }
                });
            });
        }


        // Initialization function
        async function init() {
            const canvas = document.getElementById('threejs-canvas');
            const loadingOverlay = document.getElementById('loading-overlay');

            // --- Load JSON data from file ---
            try {
                const response = await fetch(JSON_FILE_PATH);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                jsonData = await response.json();
                if (!Array.isArray(jsonData) || jsonData.length === 0) {
                    throw new Error("JSON data is empty or not an array.");
                }
            } catch (error) {
                console.error("Failed to load or parse JSON data:", error);
                loadingOverlay.textContent = `Error loading data: ${error.message}`;
                return; // Stop initialization if data fails to load
            }


            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333333);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, canvas: canvas });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.outputEncoding = THREE.sRGBEncoding;

            // Lights - Adjusted for self-illuminating materials
            // Ambient light provides a general brightness, but emissive materials will dominate.
            // const ambientLight = new THREE.AmbientLight(0xffffff, 0.2); // Reduced intensity
            // scene.add(ambientLight);
            // Removed directional light as objects will be self-illuminating

            // OrbitControls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.addEventListener('change', () => {
                needsGLBUpdate = true;
            });


            // --- Load GLB Models ---
            const loader = new GLTFLoader();
            const loadingPromises = [];

            const modelsGroup = new THREE.Group();
            scene.add(modelsGroup);

            for (let i = 0; i < jsonData.length; i++) {
                const data = jsonData[i];
                const promise = loader.loadAsync(data.glb).then((gltf) => {
                    const model = gltf.scene;
                    model.name = `model_${i}`;

                    const modelWorldPosition = getPositionFromExtrinsic(data.extrinsic);
                    model.position.copy(modelWorldPosition);

                    model.scale.set(0.5, 0.5, 0.5);

                    // Prepare materials for direct color rendering and transparency
                    prepareModelMaterials(model);

                    modelsGroup.add(model);
                    loadedModels.push({
                        model: model,
                        originalExtrinsic: data.extrinsic,
                        worldPosition: modelWorldPosition
                    });
                    model.visible = true;
                }).catch((error) => {
                    console.error(`Error loading GLB from ${data.glb}:`, error);
                });
                loadingPromises.push(promise);
            }

            // Wait for all models to load
            await Promise.all(loadingPromises);
            loadingOverlay.style.display = 'none';

            // --- Set initial camera state based on the first JSON entry ---
            if (jsonData.length > 0) {
                const firstEntry = jsonData[0];
                setupCameraFromMatrices(camera, firstEntry.intrinsic, firstEntry.extrinsic, canvas.width, canvas.height);
                controls.target.copy(camera.position).add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(10));
                controls.update();
            } else {
                camera.position.set(0, 5, 10);
                camera.lookAt(0, 0, 0);
            }

            needsGLBUpdate = true;
            updateGLBVisibility();

            animate();

            window.addEventListener('resize', onWindowResize, false);
        }

        // Resize handler
        function onWindowResize() {
            const canvas = renderer.domElement;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            controls.update();
            needsGLBUpdate = true;
            updateGLBVisibility();
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            updateGLBVisibility();
            renderer.render(scene, camera);
        }

        window.onload = init;

    </script>
</body>
</html>
